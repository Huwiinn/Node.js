Q. 아래 두 exports의 차이를 모르겠습니다.module.exports = router;
exports.routes = router;

A. 1번과 2번은 Node.js에서 모듈을 내보낼 때 사용되는 두 가지 방식입니다.

module.exports = router;: 이 코드는 현재 모듈에서 router 객체를 내보냅니다. 이것은 일반적으로 모듈이 단일 개체 또는 함수를 내보낼 때 사용됩니다. 이 모듈을 다른 파일에서 불러올 때, require 함수를 사용하여 불러온 모듈은 router 객체가 될 것입니다.

exports.routes = router;: 이 코드는 exports 객체에 routes라는 속성을 추가하고 그 값으로 router 객체를 할당합니다. 이것은 같은 모듈에서 여러 개의 항목을 내보낼 때 사용됩니다. 예를 들어, 모듈에서 여러 개의 함수나 객체를 내보낼 때, 이러한 항목들을 exports 객체의 속성으로 추가하여 불러오는 쪽에서는 필요한 항목을 선택적으로 가져올 수 있습니다.

두 가지 방식 모두 모듈을 내보내는 데 사용됩니다. 하지만 첫 번째 방식은 모듈 전체를 덮어쓰는 반면, 두 번째 방식은 exports 객체에 추가하는 방식으로 확장할 수 있습니다.

<hr>

Q. `products.push(...[{ title: req.body.title }]);`를 사용하면 배열 안에 배열이 들어갈 줄 알았습니다. 그러나 flat array로 나오는 것을 보고 만족했습니다. 왜 이중 배열이 되지 않나요?
A. push 메소드에 전개 연산자(...)를 사용할 때, 전개 연산자는 배열 안의 요소를 개별적인 항목으로 확장시킵니다. 따라서 `[{ title: req.body.title }]`는 배열 내에 객체를 포함하는 배열입니다.

하지만 push(...[{ title: req.body.title }])를 사용하면 전개 연산자가 배열 내에 있는 객체를 개별적인 항목으로 확장하여 배열에 추가합니다. 즉, 배열 안에 배열이 들어가는 것이 아니라 배열 안의 객체가 그대로 배열에 추가됩니다.

따라서 결과적으로는 flat array가 나오게 됩니다. 이렇게 함으로써 배열에 있는 객체들이 하나씩 배열에 추가되는 것을 볼 수 있습니다.
